<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Awesome sshconfig by mgarces</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Awesome sshconfig</h1>
        <p>My collection of hacks for SSHConfig</p>

        <p class="view"><a href="https://github.com/mgarces/awesome_sshconfig">View the Project on GitHub <small>mgarces/awesome_sshconfig</small></a></p>


        <ul>
          <li><a href="https://github.com/mgarces/awesome_sshconfig/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mgarces/awesome_sshconfig/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mgarces/awesome_sshconfig">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="awesome-sshconfig" class="anchor" href="#awesome-sshconfig" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/mgarces/awesome_sshconfig">Awesome <em>SSHConfig</em></a>
</h1>

<p>A curated list of awesome hacks for <a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/ssh_config.5?query=ssh_config">SSH_Config</a>; for several years I've improved the use of my ssh_config file, and here I share everything I have obtained so far; I use this on Mac OS X, but should be straighforward to addapt this to Linux.</p>

<p>So far, here is what I have obtained:</p>

<ul>
<li>
<a href="https://github.com/mgarces/awesome_sshconfig">Awesome <em>SSHConfig</em></a>

<ul>
<li><a href="#separated-ssh-config-files">Separated SSH config files</a></li>
<li><a href="#a-sane-default-config-file">A sane <em>default</em> config file</a></li>
<li><a href="#contromaster--controlpath">ControMaster / ControlPath</a></li>
<li><a href="#pki-authentication">PKI Authentication</a></li>
<li><a href="#tunnels">Tunnels</a></li>
<li><a href="#socks-proxy">SOCKS Proxy</a></li>
<li><a href="#jump-hosts">Jump Hosts</a></li>
<li><a href="#remote-copy">Remote copy</a></li>
<li><a href="#forward-agent">Forward Agent</a></li>
<li><a href="#keep-alive">Keep Alive</a></li>
<li><a href="#default_user">Default user defined by context</a></li>
</ul>
</li>
</ul>

<h2>
<a id="separated-ssh-config-files" class="anchor" href="#separated-ssh-config-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>Separated SSH config files</h2>

<p>OpenSSH does not have an option to read several config files, or including everything inside a given directory; it only reads options, either from the command line, from <em>/etc/ssh/ssh_config</em> or <em>~/.ssh/config</em>.</p>

<p>This is fine, if you have a couple of hosts on your <em>SSHConfig</em> file, but if that grows, and you are like me, and have hundreds of hosts, there is a need to separate config files, to differentiate for example, <strong>Production</strong> from <strong>Development</strong>.</p>

<p>To obtain this, first create a folder inside your ~/.ssh, lets call it <em>configs</em>; after this, throw your config files inside, using the <em>.config</em> extension, and also add a file with the name <em>default</em>.</p>

<p>Now here is the fun part! Add the next aliases to your <em>.bashrc</em> (or <em>.zshrc</em>, if you are with the cool kids):</p>

<pre><code>alias sshconfig="vim ~/.ssh/configs"

alias sshcompile="echo -n &gt;! ~/.ssh/config &amp;&amp; cat
~/.ssh/configs/*.config &gt;&gt; ~/.ssh/config &amp;&amp; cat ~/.ssh/configs/default
&gt;&gt; ~/.ssh/config"

alias ssh="sshcompile &amp;&amp; ssh"
</code></pre>

<p>The last line is optional, you can comment it if you want to "compile" <em>SSHConfig</em> manually; leave it like this, if you want to "compile" SSConfig each time you connect to a host (recommended). <em>sshcompile</em> cleans the ~/.ssh/config, concatenates all the <em>.config</em> files inside the directory, and lastly, concatenates the <em>default</em> file to the end of the config; this way, you get your <em>SSHConfig</em> file all organized.</p>

<h2>
<a id="a-sane-default-config-file" class="anchor" href="#a-sane-default-config-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>A sane <em>default</em> config file</h2>

<p>A good place to start with your <strong>SSHConfig</strong> is to setup a global default file, which will be added at the end of the final config file. I usually set all the sane defaults there, and also give some examples in the form of commentaries, for future generations :). I have provided a good base in the <em>configs</em> directory, so you can start using it right away.</p>

<pre><code>###################################################
############ GLOBAL SETTINGS ######################
###################################################
# default config from
# https://github.com/mgarces/awesome_sshconfig
###################################################

Host *
  ControlMaster auto
  ControlPath ~/.ssh/tmp/%r@%h:%p
  IdentityFile ~/.ssh/keys/id_rsa
  User myuser
  ForwardAgent yes
  Port 22
  ServerAliveInterval 60
  ServerAliveCountMax 3
  RemoteForward 55555 127.0.0.1:55555
###################################################
#This will force "User root"
Host r.*
  User root
###################################################
# EXAMPLE FORWARDS
# Put remote service, on local port
# EX: bring remote 8080 to local 8080
#
#      LocalForward localhost:8080 localhost:8080
#
# Put local service, on remote port
# EX: push local port 22, to remote 2222
#
#
#     RemoteForward localhost:2222 localhost:22
#
# Create a dynamic tunnel, can be used has
# SOCKS5 proxy
#
#     DynamicForward localhost:7777
#
#
# Now you can configure your browser to use
# localhost:7777 SOCKS5, and your HTTP gateway is the
# remote server
</code></pre>

<p>I will explain what most of this stuff does in the next sections, for now, just notice the *<em>Host *</em>* declaration; this affects all hosts, and its overwritten if you declare it inside a given host or on the command line. For example, imagine if you are connecting to a server, and the user it's not <em>myuser</em>... you either can specify that on the command line using:</p>

<pre><code>ssh anotheruser@remotehost
</code></pre>

<p>or you can declare it in a host entry on the <em>SSHConfig</em> file:</p>

<pre><code>Host remotehost
  HostName remotehost.example.com
  User anotherUser
</code></pre>

<p>The default it's just that, something to fall back if you don't specify it.</p>

<h2>
<a id="contromaster--controlpath" class="anchor" href="#contromaster--controlpath" aria-hidden="true"><span class="octicon octicon-link"></span></a>ControMaster / ControlPath</h2>

<p>During a normal work day, you might connect to a lot of systems, and use public/private key authentication; this is fine, but most of the times, even though we have tools like <em>screen</em> that allow us to have multiple terminals on the remote server, it's way faster to just open a new connection to the server. Each time you connect to a remote server, you end up creating a new connection and socket, and depending on the size and security of your keys, or if you are using password authentication (shame on you), it get's a little anoying to wait those seconds for the connection, or having to type, over and over again a password. Also, as we explain further down this document, when using Jump Hosts, if you do not have <em>ControlMaster</em> on, you will have to authenticate each time on the <em>server-in-the-middle</em> for your remote server; I can not emphasize how much boring this is. <em>SSHConfig</em> manual pages tell us this:</p>

<pre><code>ControlMaster

             Enables the sharing of multiple sessions over a single
network connection.  When set to ``yes'', ssh(1) will listen for
connections on a control socket specified using the ControlPath
argument.  Additional sessions can connect to
             this socket using the same ControlPath with ControlMaster
set to ``no'' (the default).  These sessions will try to reuse the
master instance's network connection rather than initiating new ones,
but will fall back to connecting
             normally if the control socket does not exist, or is not
listening.
</code></pre>

<p>I recommend creating a <em>tmp</em> directory inside <em>~/.ssh/</em> and store everything related to <em>ControlMaster/ControlPath</em> inside, like is noted on the <em>default</em> config file.</p>

<pre><code>  ControlMaster auto
  ControlPath ~/.ssh/tmp/%r@%h:%p
</code></pre>

<p>From now on, each time you reconnect to a host, that you are already connected, <em>ControlMaster</em> will share the same connection, no matter how many times you use this (whick can be a lot, when you are using <a href="#jump-hosts">JumpHosts</a>).</p>

<h2>
<a id="pki-authentication" class="anchor" href="#pki-authentication" aria-hidden="true"><span class="octicon octicon-link"></span></a>PKI Authentication</h2>

<p>authentication without passwords, using strong public/private keys</p>

<h2>
<a id="tunnels" class="anchor" href="#tunnels" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tunnels</h2>

<p>exposing remote and local ports</p>

<h2>
<a id="socks-proxy" class="anchor" href="#socks-proxy" aria-hidden="true"><span class="octicon octicon-link"></span></a>SOCKS Proxy</h2>

<p>VPN Browser navigation</p>

<h2>
<a id="jump-hosts" class="anchor" href="#jump-hosts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jump Hosts</h2>

<p>Imagine this scenario: I use a IPSec VPN connection to my work, and the security guys are not very fond for SSH, but I ended up convincing them to allow me, at least, to connect to one host, which has access to all the other hosts in the network, or, at least some of them; I have disallowed passwords, and I'm using a combination of PKI with One Time Password (using <a href="https://github.com/google/google-authenticator">Google Auth</a>).</p>

<p>I could access my servers the usual (newbie) way, in where I access the <strong>JUMPHOST</strong> and then I access the required server, example:</p>

<pre><code>ssh jumphost
    [myuser@JUMPHOST01 ~]$
ssh insidehost
    [myuser@INSIDEHOST01~]$
</code></pre>

<p>This is fun and all, and it works, but it gets boring quick! At least we are already using ControlMaster, so we only authenticate the first time (remember, here I am using PKI+OTP).</p>

<p>But there is a better, cleaner solution! First, lets create a entry, for the <strong>INSIDEHOST01</strong> and for a second host, let's call it <strong>INSIDEHOST02</strong>:</p>

<pre><code>Host insidehost1 j.insidehost1
  HostName insidehost01.example.com

Host insidehost2 j.insidehost2
  HostName insidehost02.example.com
</code></pre>

<p>I could setup four different entries for these two hosts, one for the normal connection, another for using the jump host, but I use a trick, where I can specifie multiple alias in the <strong>Host</strong> parameter; this way, I can create a default entry for the <strong>j.hosts</strong> entry, like we did on the *<em>Host *</em>*. Just add this inside <em>default</em> config file, or create a <em>JUMP.config</em> inside the <em>configs</em> directory:</p>

<pre><code>  Host jumphost
    HostName jumphost01.example.com

  Host j.*
  ProxyCommand ssh jumphost nc -w 120 %h %p
</code></pre>

<p>You can create several different jump hosts, depending on context, and you can also jump more then one server, for example, if you need to get to <em>insidehost1</em> to reach <em>insidehost2</em>, just declare:</p>

<pre><code>Host insidehost2
  HostName insidehost02.example.com
  ProxyCommand ssh j.insidehost1 nc -w 120 %h %p
</code></pre>

<p>This way, you first SSH to JUMPHOST01, then to INSIDEHOST01, and finally to INSIDEHOST02, everything automatically. If you are using public key authentication, and you already are connected to the first jumphost, you will login directly on the final destination.</p>

<p>Note that any option you give to a jumphost, will be set on the final destination, for example, a port forwarding; it will no be forwarded inside the first jumphost.</p>

<h2>
<a id="remote-copy" class="anchor" href="#remote-copy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Remote copy</h2>

<p>One thing I use a lot on the command line (on MacOS X) is <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html">pbcopy</a>. If I need to copy the contents of some file, let's say it, a log file, I can do:</p>

<pre><code>cat example.log | pbcopy
</code></pre>

<p>and the contents of <em>example.log</em> will be on my clipboard, ready to be pasted somewhere, like in a <a href="https://gist.github.com/">Gist</a>.</p>

<p>This works great, but only on <em>localhost</em>, and most of the time I am working on remote servers, so it would be great to have <strong>pbcopy</strong> at my hands on those servers; I usally just select with the mouse some text, but if the text is very big, I have to copy the file to localhost, and use <strong>pbcopy</strong>, or if my user has permissions to access that file, I end up doing:</p>

<pre><code>ssh somehost cat /var/log/example.log | pbcopy
</code></pre>

<p>It works, but, wouldn't be great to be able to pull pbcopy, straight where I'm working?</p>

<p>My first approach to this solution was to do a <strong>RemoteForward</strong> of my localhost SSH server port (22), to remote port 55555, and create and alias on the remote server (<em>.bashrc</em>):</p>

<pre><code>alias pbcopy='ssh -p55555 localuser@localhost pbcopy'
</code></pre>

<p>This works, because I SSH into my localhost, and run pbcopy, but there is a better way to do it, has I found out later; other users needed this, and implementend a better way, using the <a href="http://nc110.sourceforge.net/">netcat</a> (nc). First, you <em>daemonize</em> a local listener, for example, inside a <a href="https://www.gnu.org/software/screen/"><em>Screen</em></a></p>

<pre><code>while (true); do nc -l 55555 | pbcopy; done
</code></pre>

<p>You still need to RemoteForward something to the remote host, so I just put that on the <em>default</em> file (we did that already):</p>

<pre><code>RemoteForward 55555 127.0.0.1:55555
</code></pre>

<p>Now, we need to define on our remote hosts, a different alias:</p>

<pre><code>alias pbcopy='nc localhost 55555'
</code></pre>

<p>And thats it! Next time, you are on remote server you can use <em>pbcopy</em> as you would normally use it on <em>localhost</em>.</p>

<h3>
<a id="a-better-way-to-daemonize-pbcopy" class="anchor" href="#a-better-way-to-daemonize-pbcopy" aria-hidden="true"><span class="octicon octicon-link"></span></a>A better way to <em>daemonize</em> pbcopy</h3>

<p>By now you should get the concept of <em>daemonizing</em> pbcopy; if you are using Linux, I will add a better way to do this later. If you are like me, and are using MacOS X, there is a better way to achieve a pbcopy <em>daemon</em> and it's using the built in <a href="https://en.wikipedia.org/wiki/Launchd">launchd</a>.</p>

<p>Simply add the <a href="https://github.com/mgarces/awesome_sshconfig/blob/master/misc/pbcopy.plist">provided</a> <em>launchd</em> script to <em>~/Library/LaunchAgents/pbcopy.plist</em> and run:</p>

<pre><code>launchctl load ~/Library/LaunchAgents/pbcopy.plist
</code></pre>

<p>Now you have the pbcopy listener running, no need to use a <em>screen</em> session.</p>

<h3>
<a id="netcat-vs-ssh" class="anchor" href="#netcat-vs-ssh" aria-hidden="true"><span class="octicon octicon-link"></span></a>netcat VS SSH</h3>

<p>You should however be aware of something... by using the netcat method, any user on the same server you are, could connect to port 55555 and inject stuff on your local pasteboard; if you live well with this possibility, use netcat, if not, use my first approach, exploiting SSH <em>RemoteForward.</em></p>

<h2>
<a id="forward-agent" class="anchor" href="#forward-agent" aria-hidden="true"><span class="octicon octicon-link"></span></a>Forward Agent</h2>

<p>holding your keys to reuse</p>

<h2>
<a id="keep-alive" class="anchor" href="#keep-alive" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keep Alive</h2>

<p>..so your conection is not dropped!</p>

<h2>
<a id="default-user-defined-by-context" class="anchor" href="#default-user-defined-by-context" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default user defined by context</h2>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mgarces">mgarces</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
