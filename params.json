{"name":"Awesome sshconfig","tagline":"My collection of hacks for SSHConfig","body":"# [Awesome *SSHConfig*](https://github.com/mgarces/awesome_sshconfig)\r\nA curated list of awesome hacks for [SSH_Config](http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/ssh_config.5?query=ssh_config); for several years I've improved the use of my ssh_config file, and here I share everything I have obtained so far; I use this on Mac OS X, but should be straighforward to addapt this to Linux.\r\n\r\nSo far, here is what I have obtained:\r\n- [Awesome _SSHConfig_](https://github.com/mgarces/awesome_sshconfig)\r\n  - [Separated SSH config files](#separated-ssh-config-files)\r\n  - [A sane _default_ config file](#a-sane-default-config-file)\r\n  - [ControMaster / ControlPath](#contromaster--controlpath)\r\n  - [PKI Authentication](#pki-authentication)\r\n  - [Tunnels](#tunnels)\r\n  - [SOCKS Proxy](#socks-proxy)\r\n  - [Jump Hosts](#jump-hosts)\r\n  - [Remote copy](#remote-copy)\r\n  - [Forward Agent](#forward-agent)\r\n  - [Keep Alive](#keep-alive)\r\n  - [Default user defined by context](#default_user)\r\n\r\n## Separated SSH config files\r\nOpenSSH does not have an option to read several config files, or including everything inside a given directory; it only reads options, either from the command line, from _/etc/ssh/ssh_config_ or _~/.ssh/config_.\r\n\r\nThis is fine, if you have a couple of hosts on your _SSHConfig_ file, but if that grows, and you are like me, and have hundreds of hosts, there is a need to separate config files, to differentiate for example, **Production** from **Development**.\r\n\r\nTo obtain this, first create a folder inside your ~/.ssh, lets call it _configs_; after this, throw your config files inside, using the _.config_ extension, and also add a file with the name _default_.\r\n\r\nNow here is the fun part! Add the next aliases to your _.bashrc_ (or _.zshrc_, if you are with the cool kids):\r\n\r\n```\r\nalias sshconfig=\"vim ~/.ssh/configs\"\r\n\r\nalias sshcompile=\"echo -n >! ~/.ssh/config && cat\r\n~/.ssh/configs/*.config >> ~/.ssh/config && cat ~/.ssh/configs/default\r\n>> ~/.ssh/config\"\r\n\r\nalias ssh=\"sshcompile && ssh\"\r\n```\r\n\r\nThe last line is optional, you can comment it if you want to \"compile\" _SSHConfig_ manually; leave it like this, if you want to \"compile\" SSConfig each time you connect to a host (recommended). _sshcompile_ cleans the ~/.ssh/config, concatenates all the _.config_ files inside the directory, and lastly, concatenates the _default_ file to the end of the config; this way, you get your _SSHConfig_ file all organized.\r\n\r\n## A sane *default* config file\r\nA good place to start with your **SSHConfig** is to setup a global default file, which will be added at the end of the final config file. I usually set all the sane defaults there, and also give some examples in the form of commentaries, for future generations :). I have provided a good base in the _configs_ directory, so you can start using it right away.\r\n\r\n```\r\n###################################################\r\n############ GLOBAL SETTINGS ######################\r\n###################################################\r\n# default config from\r\n# https://github.com/mgarces/awesome_sshconfig\r\n###################################################\r\n\r\nHost *\r\n  ControlMaster auto\r\n  ControlPath ~/.ssh/tmp/%r@%h:%p\r\n  IdentityFile ~/.ssh/keys/id_rsa\r\n  User myuser\r\n  ForwardAgent yes\r\n  Port 22\r\n  ServerAliveInterval 60\r\n  ServerAliveCountMax 3\r\n  RemoteForward 55555 127.0.0.1:55555\r\n###################################################\r\n#This will force \"User root\"\r\nHost r.*\r\n  User root\r\n###################################################\r\n# EXAMPLE FORWARDS\r\n# Put remote service, on local port\r\n# EX: bring remote 8080 to local 8080\r\n#\r\n#      LocalForward localhost:8080 localhost:8080\r\n#\r\n# Put local service, on remote port\r\n# EX: push local port 22, to remote 2222\r\n#\r\n#\r\n#     RemoteForward localhost:2222 localhost:22\r\n#\r\n# Create a dynamic tunnel, can be used has\r\n# SOCKS5 proxy\r\n#\r\n#     DynamicForward localhost:7777\r\n#\r\n#\r\n# Now you can configure your browser to use\r\n# localhost:7777 SOCKS5, and your HTTP gateway is the\r\n# remote server\r\n```\r\n\r\nI will explain what most of this stuff does in the next sections, for now, just notice the **Host *** declaration; this affects all hosts, and its overwritten if you declare it inside a given host or on the command line. For example, imagine if you are connecting to a server, and the user it's not _myuser_... you either can specify that on the command line using:\r\n\r\n```\r\nssh anotheruser@remotehost\r\n```\r\n\r\nor you can declare it in a host entry on the _SSHConfig_ file:\r\n\r\n```\r\nHost remotehost\r\n  HostName remotehost.example.com\r\n  User anotherUser\r\n```\r\n\r\nThe default it's just that, something to fall back if you don't specify it.\r\n\r\n## ControMaster / ControlPath\r\nDuring a normal work day, you might connect to a lot of systems, and use public/private key authentication; this is fine, but most of the times, even though we have tools like _screen_ that allow us to have multiple terminals on the remote server, it's way faster to just open a new connection to the server. Each time you connect to a remote server, you end up creating a new connection and socket, and depending on the size and security of your keys, or if you are using password authentication (shame on you), it get's a little anoying to wait those seconds for the connection, or having to type, over and over again a password. Also, as we explain further down this document, when using Jump Hosts, if you do not have _ControlMaster_ on, you will have to authenticate each time on the _server-in-the-middle_ for your remote server; I can not emphasize how much boring this is. _SSHConfig_ manual pages tell us this:\r\n\r\n```\r\nControlMaster\r\n\r\n             Enables the sharing of multiple sessions over a single\r\nnetwork connection.  When set to ``yes'', ssh(1) will listen for\r\nconnections on a control socket specified using the ControlPath\r\nargument.  Additional sessions can connect to\r\n             this socket using the same ControlPath with ControlMaster\r\nset to ``no'' (the default).  These sessions will try to reuse the\r\nmaster instance's network connection rather than initiating new ones,\r\nbut will fall back to connecting\r\n             normally if the control socket does not exist, or is not\r\nlistening.\r\n```\r\n\r\nI recommend creating a _tmp_ directory inside _~/.ssh/_ and store everything related to _ControlMaster/ControlPath_ inside, like is noted on the _default_ config file.\r\n\r\n```\r\n  ControlMaster auto\r\n  ControlPath ~/.ssh/tmp/%r@%h:%p\r\n```\r\n\r\nFrom now on, each time you reconnect to a host, that you are already connected, _ControlMaster_ will share the same connection, no matter how many times you use this (whick can be a lot, when you are using [JumpHosts](#jump-hosts)).\r\n\r\n## PKI Authentication\r\nauthentication without passwords, using strong public/private keys\r\n\r\n## Tunnels\r\nexposing remote and local ports\r\n\r\n## SOCKS Proxy\r\nVPN Browser navigation\r\n\r\n## Jump Hosts\r\nImagine this scenario: I use a IPSec VPN connection to my work, and the security guys are not very fond for SSH, but I ended up convincing them to allow me, at least, to connect to one host, which has access to all the other hosts in the network, or, at least some of them; I have disallowed passwords, and I'm using a combination of PKI with One Time Password (using [Google Auth](https://github.com/google/google-authenticator)).\r\n\r\nI could access my servers the usual (newbie) way, in where I access the **JUMPHOST** and then I access the required server, example:\r\n\r\n```\r\nssh jumphost\r\n    [myuser@JUMPHOST01 ~]$\r\nssh insidehost\r\n    [myuser@INSIDEHOST01~]$\r\n```\r\n\r\nThis is fun and all, and it works, but it gets boring quick! At least we are already using ControlMaster, so we only authenticate the first time (remember, here I am using PKI+OTP).\r\n\r\nBut there is a better, cleaner solution! First, lets create a entry, for the **INSIDEHOST01** and for a second host, let's call it **INSIDEHOST02**:\r\n\r\n```\r\nHost insidehost1 j.insidehost1\r\n  HostName insidehost01.example.com\r\n\r\nHost insidehost2 j.insidehost2\r\n  HostName insidehost02.example.com\r\n```\r\n\r\nI could setup four different entries for these two hosts, one for the normal connection, another for using the jump host, but I use a trick, where I can specifie multiple alias in the **Host** parameter; this way, I can create a default entry for the **j.hosts** entry, like we did on the **Host ***. Just add this inside _default_ config file, or create a _JUMP.config_ inside the _configs_ directory:\r\n\r\n```\r\n  Host jumphost\r\n    HostName jumphost01.example.com\r\n\r\n  Host j.*\r\n  ProxyCommand ssh jumphost nc -w 120 %h %p\r\n```\r\n\r\nYou can create several different jump hosts, depending on context, and you can also jump more then one server, for example, if you need to get to _insidehost1_ to reach _insidehost2_, just declare:\r\n\r\n```\r\nHost insidehost2\r\n  HostName insidehost02.example.com\r\n  ProxyCommand ssh j.insidehost1 nc -w 120 %h %p\r\n```\r\n\r\nThis way, you first SSH to JUMPHOST01, then to INSIDEHOST01, and finally to INSIDEHOST02, everything automatically. If you are using public key authentication, and you already are connected to the first jumphost, you will login directly on the final destination.\r\n\r\nNote that any option you give to a jumphost, will be set on the final destination, for example, a port forwarding; it will no be forwarded inside the first jumphost.\r\n\r\n## Remote copy\r\nOne thing I use a lot on the command line (on MacOS X) is [pbcopy](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html). If I need to copy the contents of some file, let's say it, a log file, I can do:\r\n\r\n```\r\ncat example.log | pbcopy\r\n```\r\n\r\nand the contents of _example.log_ will be on my clipboard, ready to be pasted somewhere, like in a [Gist](https://gist.github.com/).\r\n\r\nThis works great, but only on _localhost_, and most of the time I am working on remote servers, so it would be great to have **pbcopy** at my hands on those servers; I usally just select with the mouse some text, but if the text is very big, I have to copy the file to localhost, and use **pbcopy**, or if my user has permissions to access that file, I end up doing:\r\n\r\n```\r\nssh somehost cat /var/log/example.log | pbcopy\r\n```\r\n\r\nIt works, but, wouldn't be great to be able to pull pbcopy, straight where I'm working?\r\n\r\nMy first approach to this solution was to do a **RemoteForward** of my localhost SSH server port (22), to remote port 55555, and create and alias on the remote server (_.bashrc_):\r\n\r\n```\r\nalias pbcopy='ssh -p55555 localuser@localhost pbcopy'\r\n```\r\n\r\nThis works, because I SSH into my localhost, and run pbcopy, but there is a better way to do it, has I found out later; other users needed this, and implementend a better way, using the [netcat](http://nc110.sourceforge.net/) (nc). First, you _daemonize_ a local listener, for example, inside a [_Screen_](https://www.gnu.org/software/screen/)\r\n\r\n```\r\nwhile (true); do nc -l 55555 | pbcopy; done\r\n```\r\n\r\nYou still need to RemoteForward something to the remote host, so I just put that on the _default_ file (we did that already):\r\n\r\n```\r\nRemoteForward 55555 127.0.0.1:55555\r\n```\r\n\r\nNow, we need to define on our remote hosts, a different alias:\r\n\r\n```\r\nalias pbcopy='nc localhost 55555'\r\n```\r\n\r\nAnd thats it! Next time, you are on remote server you can use _pbcopy_ as you would normally use it on _localhost_.\r\n\r\n### A better way to _daemonize_ pbcopy\r\nBy now you should get the concept of _daemonizing_ pbcopy; if you are using Linux, I will add a better way to do this later. If you are like me, and are using MacOS X, there is a better way to achieve a pbcopy _daemon_ and it's using the built in [launchd](https://en.wikipedia.org/wiki/Launchd).\r\n\r\nSimply add the [provided](https://github.com/mgarces/awesome_sshconfig/blob/master/misc/pbcopy.plist) _launchd_ script to _~/Library/LaunchAgents/pbcopy.plist_ and run:\r\n\r\n```\r\nlaunchctl load ~/Library/LaunchAgents/pbcopy.plist\r\n```\r\n\r\nNow you have the pbcopy listener running, no need to use a _screen_ session.\r\n\r\n### netcat VS SSH\r\nYou should however be aware of something... by using the netcat method, any user on the same server you are, could connect to port 55555 and inject stuff on your local pasteboard; if you live well with this possibility, use netcat, if not, use my first approach, exploiting SSH _RemoteForward._\r\n\r\n## Forward Agent\r\nholding your keys to reuse\r\n\r\n## Keep Alive\r\n..so your conection is not dropped!\r\n\r\n## Default user defined by context\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}